[ 50%] Building CXX object CMakeFiles/starter_compiler.dir/Source/Main.cpp.o
In file included from /root/workdir/Include/Warp/CtpgUtilities.hpp:1,
                 from /root/workdir/Include/Warp/ExpressionTree.hpp:1,
                 from /root/workdir/Include/Warp/AbstractSyntaxTreeUtilities.hpp:1,
                 from /root/workdir/Include/Warp/ExpressionAnalysis.hpp:1,
                 from /root/workdir/Source/Main.cpp:10:
/root/workdir/Include/Warp/Utilities.hpp: In instantiation of struct FindTypeIndex<4, long unsigned int, Node<NodeType::Literal> >':
/root/workdir/Include/Warp/Utilities.hpp:146:16:   recursively required from 'constexpr const size_t FindTypeIndex<1, long unsigned int, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>, Node<NodeType::Literal> >::type_index'
/root/workdir/Include/Warp/Utilities.hpp:146:16:   required from constexpr const size_t FindTypeIndex<0, long unsigned int, Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>, Node<NodeType::Literal> >::type_index'
/root/workdir/Include/Warp/Utilities.hpp:243:16:   required from constexpr const size_t FindTypeIndexDecay<0, long unsigned int, Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>, Node<NodeType::Literal> >::type_index'`
/root/workdir/Include/Warp/Utilities.hpp:581:24:   required from const auto& print_i(const X&, std::in_place_type_t<Alts>...) [with X = long unsigned int;
auto out = <lambda closure object> AutoVariant<
    Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>,
    Node<NodeType::Literal>>::AutoVariant<Node<NodeType::Literal>,
                                          long unsigned int>(
    std::in_place_type_t<Node<NodeType::Literal>>,
    long unsigned int)::<lambda(const long unsigned int &)>();
auto sep = <lambda closure object> AutoVariant<
    Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>,
    Node<NodeType::Literal>>::AutoVariant<Node<NodeType::Literal>,
                                          long unsigned int>(
    std::in_place_type_t<Node<NodeType::Literal>>,
    long unsigned int)::<lambda(std::string)>(); Alts = {Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>, Node<NodeType::Literal>}]
/root/workdir/Include/Warp/Utilities.hpp:604:43:   required from constexpr AutoVariant<ParameterTypes>::AutoVariant(std::in_place_type_t<_Tp>, InitializersParameterTypes ...) [with AlternativeParameterType = Node<NodeType::Literal>; InitializersParameterTypes = {long unsigned int}; ParameterTypes = {Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>, Node<NodeType::Literal>}]
/root/workdir/Include/Warp/Utilities.hpp:731:28:   required from constexpr NotSoUniquePointer<StorageType>::NotSoUniquePointer(std::in_place_type_t<_Tp>, InitializersParameterTypes ...) [with InitializersParameterTypes = {std::in_place_type_t<Node<NodeType::Literal> >, long unsigned int}; StorageType = AutoVariant<Node<FactorMultiply>, Node<FactorDivide>, Node<SumAdd>, Node<SumSubtract>, Node<NodeType::Literal> >]
/root/workdir/Include/Warp/AbstractSyntaxTreeUtilities.hpp:41:13:   required from constexpr VariantType allocate_integral_literal_node(auto:69) [with DataLiteralType = long unsigned int; auto:69 = ctpg::term_value<std::basic_string_view<char> >; VariantType = Variant]
/root/workdir/Source/Main.cpp:67:97:   required from <lambda(auto:74)> [with auto:74 = ctpg::term_value<std::basic_string_view<char> >]
/root/.conan/data/ctpg/1.3.6/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/ctpg.hpp:2503:32:   required from static constexpr LValueType ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::reduce_value_impl(const F&, ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::value_variant_type*, std::index_sequence<I ...>) [with F = <lambda(auto:74)>; LValueType = Variant; RValueType = {ctpg::term_value<std::basic_string_view<char, std::char_traits<char> > >}; long unsigned int ...I = {0}; RootValueType = Variant; Terms = {ctpg::char_term, ctpg::char_term, ctpg::char_term, ctpg::char_term, ctpg::regex_term<natural_number_regex>, ctpg::char_term, ctpg::char_term}; NTerms = {ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::nterm<Variant >}; Rules = {ctpg::detail::rule<<lambda(auto:74)>, ctpg::nterm<Variant >, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:75, auto:76, const auto:77&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:78, auto:79, const auto:80&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:81, auto:82, auto:83)>, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant >, ctpg::char_term>, ctpg::detail::rule<<lambda(auto:84)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:85, auto:86, auto:87)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:88, auto:89, auto:90)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:91)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:92, auto:93, const auto:94&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:95, auto:96, const auto:97&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >}; LexerUsage = ctpg::use_generated_lexer; ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::value_variant_type = std::variant<std::nullptr_t, ctpg::no_type, Variant, ctpg::term_value<char>, ctpg::term_value<std::basic_string_view<char, std::char_traits<char> > > >; std::index_sequence<I ...> = std::integer_sequence<long unsigned int, 0>]
/root/.conan/data/ctpg/1.3.6/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/ctpg.hpp:2510:60:   required from static constexpr ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::value_variant_type ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::reduce_value(const rule_tuple_type&, ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::value_variant_type*) [with long unsigned int RuleIdx = 0; F = <lambda(auto:74)>; LValueType = Variant; RValueType = {ctpg::term_value<std::basic_string_view<char, std::char_traits<char> > >}; RootValueType = Variant; Terms = {ctpg::char_term, ctpg::char_term, ctpg::char_term, ctpg::char_term, ctpg::regex_term<natural_number_regex>, ctpg::char_term, ctpg::char_term}; NTerms = {ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::nterm<Variant >}; Rules = {ctpg::detail::rule<<lambda(auto:74)>, ctpg::nterm<Variant >, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:75, auto:76, const auto:77&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:78, auto:79, const auto:80&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:81, auto:82, auto:83)>, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant >, ctpg::char_term>, ctpg::detail::rule<<lambda(auto:84)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:85, auto:86, auto:87)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:88, auto:89, auto:90)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:91)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:92, auto:93, const auto:94&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:95, auto:96, const auto:97&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >}; LexerUsage = ctpg::use_generated_lexer; ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::value_variant_type = std::variant<std::nullptr_t, ctpg::no_type, Variant, ctpg::term_value<char>, ctpg::term_value<std::basic_string_view<char, std::char_traits<char> > > >; ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::rule_tuple_type = std::tuple<ctpg::detail::rule<<lambda(auto:74)>, ctpg::nterm<Variant >, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:75, auto:76, const auto:77&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:78, auto:79, const auto:80&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:81, auto:82, auto:83)>, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant >, ctpg::char_term>, ctpg::detail::rule<<lambda(auto:84)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:85, auto:86, auto:87)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:88, auto:89, auto:90)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:91)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:92, auto:93, const auto:94&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:95, auto:96, const auto:97&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > > >]
/root/.conan/data/ctpg/1.3.6/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/ctpg.hpp:2126:33:   required from constexpr void ctpg::parser<ctpg::nterm<ValueType>, std::tuple<_Types ...>, std::tuple<_Rest ...>, std::tuple<Rules ...>, LexerUsage>::analyze_rule(const ctpg::detail::rule<F, L, R ...>&, std::index_sequence<I ...>) [with long unsigned int Nr = 0; F = <lambda(auto:74)>; L = ctpg::nterm<Variant >; R = {ctpg::regex_term<natural_number_regex>}; long unsigned int ...I = {0}; RootValueType = Variant; Terms = {ctpg::char_term, ctpg::char_term, ctpg::char_term, ctpg::char_term, ctpg::regex_term<natural_number_regex>, ctpg::char_term, ctpg::char_term}; NTerms = {ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::nterm<Variant >}; Rules = {ctpg::detail::rule<<lambda(auto:74)>, ctpg::nterm<Variant >, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:75, auto:76, const auto:77&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:78, auto:79, const auto:80&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::regex_term<natural_number_regex> >, ctpg::detail::rule<<lambda(auto:81, auto:82, auto:83)>, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant >, ctpg::char_term>, ctpg::detail::rule<<lambda(auto:84)>, ctpg::nterm<Variant >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:85, auto:86, auto:87)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:88, auto:89, auto:90)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:91)>, ctpg::nterm<Variant > > >, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:92, auto:93, const auto:94&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >, ctpg::detail::rule<<lambda(auto:95, auto:96, const auto:97&)>, ctpg::nterm<Variant >, ctpg::nterm<Variant >, ctpg::char_term, ctpg::nterm<Variant > >}; LexerUsage = ctpg::use_generated_lexer; std::index_sequence<I ...> = std::integer_sequence<long unsigned int, 0>]
/root/.conan/data/ctpg/1.3.6/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/ctpg.hpp:2062:10:   required from here
/root/workdir/Include/Warp/Utilities.hpp:210:82: error: static assertion failed: Type not in type list

  210 |         static_assert( std::is_same< QueryParameterType, CurrentParameterType >::value, "Type not in type list\n" );
| ^~~~~ / root / workdir / Include / Warp /
        Utilities.hpp : 210 : 82 : note
    : std::integral_constant<bool, false>::value evaluates to false make[2]
    : ***[CMakeFiles / starter_compiler.dir /
          build.make:
                  63:CMakeFiles / starter_compiler.dir / Source /
                     Main.cpp.o] Error 1 make[1]
    : ***[CMakeFiles /
          Makefile2:76:CMakeFiles / starter_compiler.dir / all] Error 2 make
    : ***[Makefile:84:all] Error 2
